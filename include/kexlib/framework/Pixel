#pragma once

#include <algorithm>
#include <Kexdef>

namespace kex {
namespace gfx {

enum struct PixelFormat {
    unknown,
    rgb,
    rgba,
    index8
};

struct Index8 {
    uint8_t index;
};

struct Rgb {
    uint8_t red, green, blue;
};

struct Rgba {
    uint8_t red, green, blue, alpha;
};

template <class _T>
using is_pixel_type = kex::is_any_of_type<_T, Index8, Rgb, Rgba>;

struct PixelTypeinfo {
    PixelFormat format;
    size_t bits;
    size_t bytes;
};

template<PixelFormat _Format>
struct PixelTraits;

template<>
struct PixelTraits<PixelFormat::unknown> {
    using pixel_type = void;
    static constexpr auto format = PixelFormat::unknown;
    static constexpr size_t bits = 0;
    static constexpr size_t bytes = 0;
};

template<>
struct PixelTraits<PixelFormat::index8> {
    using pixel_type = Index8;
    static constexpr auto format = PixelFormat::index8;
    static constexpr size_t bits = 8;
    static constexpr size_t bytes = 1;
};

template<>
struct PixelTraits<PixelFormat::rgb> {
    using pixel_type = Rgb;
    static constexpr auto format = PixelFormat::rgb;
    static constexpr size_t bits = 24;
    static constexpr size_t bytes = 3;
};

template<>
struct PixelTraits<PixelFormat::rgba> {
    using pixel_type = Rgba;
    static constexpr auto format = PixelFormat::rgba;
    static constexpr size_t bits = 32;
    static constexpr size_t bytes = 4;
};

template <class _T>
inline void to_pixel(const _T &src, _T &dst)
{ dst = src; }

inline void to_pixel(const Rgb &src, Rgba &dst)
{ dst = Rgba { src.red, src.green, src.blue, 0xff }; }

inline void to_pixel(const Rgba &src, Rgb &dst)
{ dst = Rgb { src.red, src.green, src.blue }; }

PixelTypeinfo const &GetPixelTypeinfo(PixelFormat fmt);

template<PixelFormat _T, PixelFormat _U = _T>
class PixelReference {
public:
    using native_traits_type = PixelTraits<_T>;
    using native_pixel_type = typename native_traits_type::pixel_type;

    using conv_traits_type = PixelTraits<_U>;
    using conv_pixel_type = typename conv_traits_type::pixel_type;

private:
    native_pixel_type &mPixel;

public:

    PixelReference(native_pixel_type &pPixel) :
        mPixel(pPixel)
    {
    }

    const conv_pixel_type get() const
    {
        conv_pixel_type retval;
        to_pixel(mPixel, retval);
        return retval;
    }

    PixelReference &set(const conv_pixel_type &pPixel)
    {
        to_pixel(pPixel, mPixel);
        return *this;
    }

    const conv_pixel_type operator*() const
    {
        return get();
    }

    PixelReference &operator=(const conv_pixel_type &pPixel)
    {
        return set(pPixel);
    }

    template <PixelFormat _T2>
    PixelReference &operator=(const PixelReference<_T2, _U> &x)
    {
        *this = *x;
    }
};

template<PixelFormat _T, PixelFormat _U = _T>
class PixelIterator {
    size_t mWidth;
    size_t mYSkip;
    size_t mXIndex;
    uint8_t *mPixels;

public:
    using native_traits_type = PixelTraits<_T>;
    using native_pixel_type = typename native_traits_type::pixel_type;
    using reference_type = PixelReference<_T, _U>;

    PixelIterator(uint8_t *pPixels, size_t pWidth, size_t pYSkip, size_t pXIndex) :
        mPixels(pPixels),
        mWidth(pWidth),
        mYSkip(pYSkip),
        mXIndex(pXIndex)
    {
    }

    PixelIterator &operator++()
    {
        if (++mXIndex >= mWidth)
        {
            mPixels += mYSkip;
            mXIndex = 0;
        }
        mPixels += native_traits_type::bytes;
        return *this;
    }

    bool operator!=(const PixelIterator &other)
    {
        return mPixels != other.mPixels;
    }

    reference_type operator*()
    {
        return reference_type(*(native_pixel_type *)mPixels);
    }
};

} // namespace gfx
} // namespace kex


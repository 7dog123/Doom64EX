// -*- mode: c++ -*-
//-----------------------------------------------------------------------------
//
// Copyright(C) 2016 Zohar Malamant
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
// 02111-1307, USA.
//
//-----------------------------------------------------------------------------

#ifndef __KEX_IMAGE__96112498
#define __KEX_IMAGE__96112498

#include <istream>
#include "Pixel"

namespace kex {
  namespace gfx {
    class Image;

    struct ImageError : std::runtime_error
    { using std::runtime_error::runtime_error; };

    struct ImageLoadError: ImageError
    { using ImageError::ImageError; };

    struct ImageSaveError: ImageError
    { using ImageError::ImageError; };

    struct ImageInfo {
        uint16 width = 0;
        uint16 height = 0;
        PixelFormat format = PixelFormat::none;
        StringView mimetype = "";
    };

    struct ImageFormatIO {
        virtual bool is_format(std::istream&) const = 0;
        virtual Image load(std::istream&) const = 0;
        virtual void save(std::ostream&, Image const&) const = 0;
        virtual StringView mimetype() const = 0;
    };

    class Image {
        const PixelInfo* mTraits = nullptr;
        uint16 mWidth = 0;
        uint16 mHeight = 0;
        std::unique_ptr<byte[]> mData = nullptr;
        Palette mPalette;
        int mOffsets[2] = { };

    public:
        Image() = default;

        Image(const Image &);

        Image(Image&&) noexcept = default;

        Image(PixelFormat format, uint16 width, uint16 height, byte *data);

        Image(PixelFormat format, uint16 width, uint16 height, std::unique_ptr<byte[]> data);

        explicit Image(PixelFormat format, uint16 width, uint16 height, noinit_tag);

        Image(std::istream&);

        Image(std::istream&, StringView mimetype);

        Image& operator=(const Image &);

        Image& operator=(Image&& other) noexcept = default;

        void load(std::istream&);

        void load(std::istream&, StringView mimetype);

        void save(std::ostream& s, StringView mimetype) const;

        Image clone() const
        {
            return Image(*this);
        }

        void reset()
        { *this = Image(); }

        byte *data_ptr()
        { return mData.get(); }

        const byte *data_ptr() const
        { return mData.get(); }

        uint8* scanline_ptr(uint16_t index);

        const uint8* scanline_ptr(uint16_t index) const;

        uint8* pixel_ptr(uint16_t x, uint16_t y);

        const uint8* pixel_ptr(uint16_t x, uint16_t y) const;

        Image& convert(PixelFormat);

        Image& resize(uint16_t width, uint16_t height);

        Image& scale(uint16_t width, uint16_t height);

        template<class T, class U = T>
        auto map()
        {
            test_pixel_format<T>(mTraits);

            auto size = pixel_traits<std::decay_t<T>>::bytes * mWidth * mHeight;
            return PixelMap<T, U>(reinterpret_cast<T*>(data_ptr()),
                                  reinterpret_cast<T*>(data_ptr() + size));
        }

        template<class T, class U = T>
        auto map() const
        {
            test_pixel_format<T>(mTraits);

            auto size = pixel_traits<std::decay_t<T>>::bytes * mWidth * mHeight;
            return PixelMap<const T, const U>(reinterpret_cast<const T*>(data_ptr()),
                                              reinterpret_cast<const T*>(data_ptr() + size));
        }

        const PixelInfo &traits() const
        { return *mTraits; }

        PixelFormat format() const
        { return mTraits->format; }

        uint16 width() const
        { return mWidth; }

        uint16 height() const
        { return mHeight; }

        const Palette &palette() const
        { return mPalette; }

        void palette(const Palette& palette)
        { mPalette = palette; }

        void palette(Palette&& palette)
        { mPalette = std::move(palette); }

        const int *offsets() const
        { return mOffsets; }

        void offsets(const int *vals)
        {
            mOffsets[0] = vals[0];
            mOffsets[1] = vals[1];
        }

        bool is_indexed() const
        { return !mTraits->color; }
    };
  }
}

#endif //__KEX_IMAGE__96112498

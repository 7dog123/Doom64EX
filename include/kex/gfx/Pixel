// -*- mode: c++ -*-
//-----------------------------------------------------------------------------
//
// Copyright(C) 2016 Zohar Malamant
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
// 02111-1307, USA.
//
//-----------------------------------------------------------------------------

#ifndef __KEX_PIXEL__13206666
#define __KEX_PIXEL__13206666

#include "kex/kexdef"

/*!
 * This header defines classes for low-level pixel operations,
 * as well as the Palette class.
 *
 * We distinguish pixel data into two groups: Color and Index.
 * Color pixels are pixels whose data is in-band. (ex: Rgb)
 * Index pixels are pixels whose color values can be found somewhere else. (ex: Index8)
 */

namespace kex {
  namespace gfx {
    struct Palette;

    class PixelFormatError : public std::logic_error {
    public:
        using std::logic_error::logic_error;

        PixelFormatError();
    };

    enum struct PixelFormat {
        none,
        index8,
        rgb,
        rgba,
    };

    struct Index8 {
        uint8 index;
    };

    struct Rgb {
        uint8 red, green, blue;
    };

    struct Rgba {
        uint8 red, green, blue, alpha;
    };

    struct index8_tag {
        using type = Index8;
    };

    struct rgb_tag {
        using type = Rgb;
    };

    struct rgba_tag {
        using type = Rgba;
    };

    template <class T>
    struct pixel_traits;

    template <>
    struct pixel_traits<Index8> {
        static constexpr auto format = PixelFormat::index8;
        static constexpr bool color = false;
        static constexpr size_t bytes = 1;
        static constexpr bool alpha = false;

        static constexpr size_t pal_size = 256;
        static constexpr int pal_mask = 0xff;

        using tag_type = index8_tag;
        static constexpr auto tag() { return index8_tag(); }
    };

    template <>
    struct pixel_traits<Rgb> {
        static constexpr auto format = PixelFormat::rgb;
        static constexpr bool color = true;
        static constexpr size_t bytes = 3;
        static constexpr bool alpha = false;

        static constexpr size_t pal_size = 0;
        static constexpr int pal_mask = 0;

        using tag_type = rgb_tag;
        static constexpr auto tag() { return rgb_tag();}
    };

    template <>
    struct pixel_traits<Rgba> {
        static constexpr auto format = PixelFormat::rgba;
        static constexpr bool color = true;
        static constexpr size_t bytes = 4;
        static constexpr bool alpha = true;

        static constexpr size_t pal_size = 0;
        static constexpr int pal_mask = 0;

        using tag_type = rgba_tag;
        static constexpr auto tag() { return rgba_tag(); }
    };

    template <class T>
    constexpr bool is_pixel = kex::is_any_same<T, Index8, Rgb, Rgba>;

    template <class T, class = void>
    struct __h_is_color_pixel : std::false_type {};

    template <class T>
    struct __h_is_color_pixel<T, void_t<decltype(pixel_traits<T>::color)>> : bool_type<pixel_traits<T>::color> {};

    template <class T>
    constexpr bool is_color_pixel = __h_is_color_pixel<T>::value;

    template <class T>
    constexpr bool is_index_pixel = is_pixel<T> && !is_color_pixel<T>;

    template <class T, class = std::enable_if_t<is_pixel<T>>>
    using get_traits_type = pixel_traits<T>;

    struct PixelInfo {
        PixelFormat format = PixelFormat::none;
        bool color = false;
        size_t bytes = 0;
        bool alpha = false;

        size_t pal_size = 0;
        int pal_mask = 0;
    };

    const PixelInfo& get_pixel_info(PixelFormat);

    template <class T>
    inline void test_pixel_format(PixelFormat format)
    {
        if (pixel_traits<T>::format != format)
            throw PixelFormatError();
    }

    template <class T>
    inline void test_pixel_format(const PixelInfo *traits)
    {
        if (pixel_traits<T>::format != traits->format)
            throw PixelFormatError();
    }

    template <class T, class U>
    struct PixelIterator;

    template <class T>
    struct PixelIterator<T, T> {
        PixelIterator(T *ptr):
            mPtr(ptr) {}

        T& operator*()
        { return *mPtr; }

        const T& operator*() const
        { return *mPtr; }

        T* operator->()
        { return mPtr; }

        const T* operator->() const
        { return mPtr; }

        bool operator==(const PixelIterator &other) const
        { return mPtr == other.mPtr; }

        bool operator!=(const PixelIterator &other) const
        { return mPtr != other.mPtr; }

        PixelIterator& operator++()
        {
            ++mPtr;
            return *this;
        }

        PixelIterator operator++(int)
        {
            PixelIterator copy(*this);
            ++mPtr;
            return copy;
        }

        PixelIterator operator+(int idx) const
        { return PixelIterator(mPtr + idx); }

        PixelIterator& operator+=(int idx)
        {
            mPtr += idx;
            return *this;
        }

        PixelIterator& operator--()
        {
            --mPtr;
            return *this;
        }

        PixelIterator operator--(int)
        {
            PixelIterator copy(*this);
            --mPtr;
            return copy;
        }

        PixelIterator operator-(int idx) const
        { return PixelIterator(mPtr - idx); }

        PixelIterator& operator-=(int idx)
        {
            mPtr -= idx;
            return *this;
        }

    private:
        T *mPtr;
    };

    template <class T, class U>
    class PixelMap {
    public:
        using iterator = PixelIterator<T, U>;
        using const_iterator = PixelIterator<const T, const U>;

        PixelMap(T *begin, T *end):
            mBegin(begin),
            mEnd(end) {}

        auto begin()
        { return iterator(mBegin); }

        auto begin() const
        { return const_iterator(mBegin); }

        auto cbegin() const
        { return const_iterator(mBegin); }

        auto end()
        { return iterator(mEnd); }

        auto end() const
        { return const_iterator(mEnd); }

        auto cend() const
        { return const_iterator(mEnd); }

    private:
        T *mBegin;
        T *mEnd;
    };

    class Palette {
        const PixelInfo *mTraits = nullptr;
        size_t mCount = 0;
        std::unique_ptr<byte[]> mData = nullptr;

    public:
        Palette() noexcept = default;

        Palette(Palette&&) noexcept = default;

        Palette(const Palette &);

        Palette(PixelFormat format, size_t count, std::unique_ptr<byte[]> data);

        Palette& operator=(Palette&&) noexcept = default;

        Palette& operator=(const Palette &);

        void reset()
        { *this = Palette(); }

        bool empty() const
        { return !(mTraits && mCount && mData); }

        byte *data_ptr()
        { return mData.get(); }

        const byte *data_ptr() const
        { return mData.get(); }

        PixelFormat format() const
        { return mTraits->format; }

        const PixelInfo &traits() const
        { return *mTraits; }

        uint8 count() const
        { return mCount; }

        const byte *color_ptr(uint8 index) const noexcept
        { return &mData[index * mTraits->bytes]; }

        template <class SrcT, class DstT>
        DstT unsafe_color(uint8 index) const noexcept
        { return convert_pixel(*reinterpret_cast<const SrcT *>(color_ptr(index)), pixel_traits<DstT>::tag); }

        template <class T, class U = T>
        auto map()
        {
            if (pixel_traits<std::decay_t<T>>::format != mTraits->format)
                throw PixelFormatError();

            return PixelMap<T, U>(reinterpret_cast<T *>(mData.get()),
                                  reinterpret_cast<T *>(mData.get()) + mCount);
        }

        template <class T, class U = T>
        auto map() const
        {
            test_pixel_format<T>(mTraits);

            return PixelMap<const T, const U>(reinterpret_cast<const T *>(mData.get()),
                                              reinterpret_cast<const T *>(mData.get()) + mCount);
        }
    };

    struct default_pixel_processor {
        template <class, class... Args>
        void color(Args&&...)
        { throw PixelFormatError("color pixel processor not implemented"); }

        template <class, class... Args>
        void index(Args&&...)
        { throw PixelFormatError("index pixel processor not implemented"); }
    };

    template <class Processor, class... Args>
    void process_pixel(Processor proc, PixelFormat fmt, Args&&... args)
    {
#define CASE(fmt, type, func) \
        case PixelFormat::fmt: \
            proc.template func<type>(std::forward<Args>(args)...); \
            break;

        switch (fmt)
        {
        CASE(index8, Index8, index)
        CASE(rgb, Rgb, color)
        CASE(rgba, Rgba, color)

        default:
            throw PixelFormatError("process_pixel doesn't have a case for this pixel type");
        }

#undef CASE
    };

    /* Identity copy_pixel */
    template <class T>
    constexpr T convert_pixel(const T &src, typename pixel_traits<T>::tag_type) noexcept
    { return src; }

    /* RGB copy_pixel */
    constexpr Rgba convert_pixel(const Rgb &src, rgba_tag) noexcept
    { return { src.red, src.green, src.blue, 0xff }; }

    /* RGBA convert_pixel */
    constexpr Rgb convert_pixel(const Rgba &src, rgb_tag) noexcept
    { return { src.red, src.green, src.blue }; }

    /*! These are sort of like unit tests */
    static_assert( is_pixel<Index8>, "");
    static_assert( is_pixel<Rgb>, "");
    static_assert( is_pixel<Rgba>, "");
    static_assert(!is_pixel<int>, "");

    static_assert(!is_color_pixel<Index8>, "");
    static_assert( is_color_pixel<Rgb>, "");
    static_assert( is_color_pixel<Rgba>, "");
    static_assert(!is_color_pixel<int>, "");

    static_assert( is_index_pixel<Index8>, "");
    static_assert(!is_index_pixel<Rgb>, "");
    static_assert(!is_index_pixel<Rgba>, "");
    static_assert(!is_index_pixel<int>, "");
  }
}

#endif //__KEX_PIXEL__13206666

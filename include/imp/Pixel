// -*- mode: c++ -*-
//-----------------------------------------------------------------------------
//
// Copyright(C) 2016 Zohar Malamant
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
// 02111-1307, USA.
//
//-----------------------------------------------------------------------------

#ifndef __IMP_PIXEL__13206666
#define __IMP_PIXEL__13206666

#include "Prelude"
#include "util/PtrIterator"

/*
 * This header defines classes for low-level pixel operations,
 * as well as the Palette class.
 *
 * We distinguish pixel data into two groups: Color and Index.
 * Color pixels are pixels whose data is in-band. (ex: Rgb)
 * Index pixels are pixels whose color values can be found somewhere else, like a Palette. (ex: Index8)
 */

namespace imp {
  namespace gfx {
    class Palette;

    enum struct PixelFormat {
        none,
        index8,
        rgb,
        rgba,
        rgba5551
    };

    namespace detail {
      template <int FromBits, int LShift, class = void>
      struct resize_component_shift {
          constexpr size_t operator()(size_t x) const
          { return x >> -LShift; }
      };

      template <int FromBits, int LShift>
      struct resize_component_shift<FromBits, LShift, std::enable_if_t<LShift < 0>> {
          constexpr size_t operator()(size_t x) const
          { return (x << LShift) + resize_component_shift<FromBits, LShift - FromBits>()(x); }
      };

      template<int FromDepth, int ToDepth>
      constexpr size_t resize_component(size_t x)
      {
          return resize_component_shift<FromDepth, ToDepth - FromDepth>()(x);
      };
    }

#pragma pack(push, 1)

    template<PixelFormat Format, size_t Red, size_t Green, size_t Blue, size_t Alpha>
    struct Color {
        static constexpr auto format = Format;
        static constexpr size_t alpha_max = (1ULL << Alpha) - 1ULL;

        size_t red : Red;
        size_t green : Green;
        size_t blue : Blue;
        size_t alpha : Alpha;

        constexpr Color() = default;

        constexpr Color(const Color &) = default;

        constexpr Color(Color &&) = default;

        constexpr Color(size_t red, size_t green, size_t blue, size_t alpha):
            red(red),
            green(green),
            blue(blue),
            alpha(alpha)
        {}

        template<PixelFormat CFormat, size_t CRed, size_t CGreen, size_t CBlue, size_t CAlpha>
        constexpr Color(const Color<CFormat, CRed, CGreen, CBlue, CAlpha> &other):
            red(detail::resize_component<CRed, Red>(other.red)),
            green(detail::resize_component<CGreen, Green>(other.green)),
            blue(detail::resize_component<CBlue, Blue>(other.blue)),
            alpha(detail::resize_component<CAlpha, Alpha>(other.alpha))
        {}

        template<PixelFormat CFormat, size_t CRed, size_t CGreen, size_t CBlue>
        constexpr Color(const Color<CFormat, CRed, CGreen, CBlue, 0> &other):
            red(detail::resize_component<CRed, Red>(other.red)),
            green(detail::resize_component<CGreen, Green>(other.green)),
            blue(detail::resize_component<CBlue, Blue>(other.blue)),
            alpha(alpha_max)
        {}

        constexpr Color &operator=(const Color &) = default;

        constexpr Color &operator=(Color &&) = default;
    };

    template<PixelFormat Format, size_t Red, size_t Green, size_t Blue>
    struct Color<Format, Red, Green, Blue, 0> {
        static constexpr auto format = Format;

        size_t red : Red;
        size_t green : Green;
        size_t blue : Blue;

        constexpr Color() = default;

        constexpr Color(const Color &) = default;

        constexpr Color(Color &&) = default;

        constexpr Color(size_t red, size_t green, size_t blue):
            red(red),
            green(green),
            blue(blue)
        {}

        template<PixelFormat CFormat, size_t CRed, size_t CGreen, size_t CBlue, size_t CAlpha>
        constexpr Color(const Color<CFormat, CRed, CGreen, CBlue, CAlpha> &other):
            red(detail::resize_component<CRed, Red>(other.red)),
            green(detail::resize_component<CGreen, Green>(other.green)),
            blue(detail::resize_component<CBlue, Blue>(other.blue))
        {}

        constexpr Color &operator=(const Color &) = default;

        constexpr Color &operator=(Color &&) = default;
    };

    template<PixelFormat Format, size_t Depth>
    struct Index {
        static constexpr auto format = Format;

        size_t index : Depth;

        constexpr Index() = default;

        constexpr Index(const Index &) = default;

        constexpr Index(Index &&) = default;

        constexpr Index(size_t index):
            index(index)
        {}

        constexpr Index &operator=(const Index &) = default;

        constexpr Index &operator=(Index &&) = default;
    };

#pragma pack(pop)

    using Index8 = Index<PixelFormat::index8, 8>;
    using Rgba = Color<PixelFormat::rgba, 8, 8, 8, 8>;
    using Rgb = Color<PixelFormat::rgb, 8, 8, 8, 0>;
    using Rgba5551 = Color<PixelFormat::rgba5551, 5, 5, 5, 1>;

    static_assert(sizeof(Rgba) == 4, "Size of RGBA struct must be 4 bytes");
    static_assert(sizeof(Rgb) == 3, "Size of RGB struct must be 3 bytes");
    static_assert(sizeof(Rgba5551) == 2, "Size of RGBA5551 struct must be 2 bytes");

    namespace detail {
      template<class T>
      struct pixel_info {
          static constexpr auto format = PixelFormat::none;
          static constexpr bool is_color = false;
          static constexpr bool is_index = false;
          static constexpr bool is_pixel = false;
          static constexpr size_t depth = 0;
      };

      template<PixelFormat F, size_t R, size_t G, size_t B, size_t A>
      struct pixel_info<Color<F, R, G, B, A>> {
          static constexpr auto format = F;
          static constexpr bool is_color = true;
          static constexpr bool is_index = false;
          static constexpr bool is_pixel = true;
          static constexpr size_t depth = R + G + B + A;
      };

      template<PixelFormat F, size_t D>
      struct pixel_info<Index<F, D>> {
          static constexpr auto format = F;
          static constexpr bool is_color = false;
          static constexpr bool is_index = true;
          static constexpr bool is_pixel = true;
          static constexpr size_t depth = D;
      };

      template <class T>
      constexpr auto is_color = pixel_info<T>::is_color;
      template <class T>
      constexpr auto is_index = pixel_info<T>::is_index;
      template <class T>
      constexpr auto is_pixel = pixel_info<T>::is_pixel;

      template <class T>
      constexpr auto is_color_it = is_color<std::iterator_traits<T>::value_type>;
      template <class T>
      constexpr auto is_index_it = is_index<std::iterator_traits<T>::value_type>;
      template <class T>
      constexpr auto is_pixel_it = is_pixel<std::iterator_traits<T>::value_type>;
    }

    /**
     * \brief A version of pixel_traits that's available at runtime
     *
     * When adding a new static constexpr field to pixel_traits, add it here
     * as well.
     */
    struct PixelInfo {
        PixelFormat format = PixelFormat::none;
        bool color = false;
        size_t bytes = 0;
        bool alpha = false;

        size_t pal_size = 0;
        int pal_mask = 0;

        template<class T>
        static PixelInfo make()
        { return { T::format }; }
    };

    /**
     * \brief Get an instance of PixelInfo based on PixelFormat
     *
     * \param format Find PixelInfo that has this format
     *
     * \return An instance of PixelInfo
     *
     * \exception PixelFormatError When PixelInfo isn't found
     */
    const PixelInfo &get_pixel_info(PixelFormat format);

    template<class T>
    class BasicPal;

    template<class T>
    class BasicPalRef;

    /*!
     * Type-erased Palette
     */
    class Pal {
        PixelFormat format_{};
        size_t size_{};
        std::unique_ptr<char[]> data_{};

    public:
        Pal() = default;

        Pal(Pal &&) = default;

        Pal(const Pal &) = default;

        template<class InputIt>
        Pal(InputIt first, InputIt last)
        {
            using type = std::decay<decltype(*first)>;
            static_assert(detail::pixel_info<type>::is_color, "");

            format_ = type::format;
            size_ = static_cast<size_t>(std::distance(last, first));
            data_ = std::make_unique<char[]>(size_ * sizeof(type));
            type *ptr = reinterpret_cast<type *>(data_.get());
            std::copy(first, last, ptr);
        }

        template<class T>
        Pal(const BasicPal<T> &other):
            Pal(other.begin(), other.end())
        {}

        template<class T>
        Pal(BasicPal<T> &&other):
            format_(other.format_),
            size_(other.size_),
            data_(std::move(other.data_))
        {}

        Pal &operator=(Pal &&) = default;

        Pal &operator=(const Pal &) = default;

        bool operator!() const
        { return data_ == nullptr; }

        operator bool() const
        { return data_ != nullptr; }

        char *data()
        { return data_.get(); }

        const char *data() const
        { return data_.get(); }

        PixelFormat format() const
        { return format_; }

        size_t size() const
        { return size_; }

        template<class T>
        BasicPalRef<T> ref()
        {
            if (T::format != format_)
                throw std::logic_error("Wrong pixel format");

            return *this;
        }

        template<class T>
        BasicPalRef<T> ref_unsafe()
        { return *this; }
    };

    template<class T>
    class BasicPalRef {
        static_assert(detail::pixel_info<T>::is_color, "T must be a colour");

        static constexpr auto format_ = T::format;
        size_t size_{};
        T *data_{};

        BasicPalRef(Pal &pal):
            size_(pal.size()),
            data_(reinterpret_cast<T*>(pal.data())) {}

        friend class Pal;

    public:
        BasicPalRef() = default;

        BasicPalRef(BasicPalRef &&) = default;

        BasicPalRef(const BasicPalRef &) = default;

        BasicPalRef(BasicPal<T> &pal) noexcept:
            size_(pal.size()),
            data_(pal.data())
        {}

        BasicPalRef &operator=(BasicPalRef &&) = default;

        BasicPalRef &operator=(const BasicPalRef &) = default;

        T *data()
        { return data_; }

        const T *data() const
        { return data_; }

        PixelFormat format() const
        { return format_; }

        size_t size() const
        { return size_; }

        bool empty() const
        { return data_ == nullptr; }

        bool operator!() const
        { return empty(); }

        operator bool() const
        { return empty(); }

        T &at(size_t i)
        {
            if (size_ < i)
                throw std::out_of_range("PaletteRef");
            return data()[i];
        }

        template<class U>
        T &at(U i)
        {
            static_assert(detail::is_index<U>, "Palette index must be of type Index or size_t");
            if (size_ < i)
                throw std::out_of_range("PaletteRef");
            return data()[i.index];
        }

        const T &at(size_t i) const
        {
            if (size_ < i)
                throw std::out_of_range("PaletteRef");
            return data()[i];
        }

        template<class U>
        const T &at(U i) const
        {
            static_assert(detail::is_index<U>, "Palette index must be of type Index or size_t");
            if (size_ < i)
                throw std::out_of_range("PaletteRef");
            return data()[i.index];
        }

        T &operator[](size_t i)
        { return data()[i]; }

        template<class U>
        T &operator[](U i)
        {
            static_assert(detail::is_index<U>, "Palette index must be of type Index or size_t");
            return data()[i.index];
        }

        const T &operator[](size_t i) const
        { return data()[i]; }

        template<class U>
        const T &operator[](U i) const
        {
            static_assert(detail::is_index<U>, "Palette index must be of type Index or size_t");
            return data()[i.index];
        }

        T *begin()
        { return data(); }

        const T *begin() const
        { return data(); }

        const T *cbegin() const
        { return data(); }

        T *end()
        { return data() + size(); }

        const T *end() const
        { return data() + size(); }

        const T *cend() const
        { return data() + size(); }
    };

    template<class T>
    class BasicPal {
        static_assert(detail::pixel_info<T>::is_color, "T must be a colour");

        static constexpr auto format_ = T::format;
        size_t size_{};
        std::unique_ptr<char[]> data_{};

        friend class VarPal;

    public:
        BasicPal() = default;

        BasicPal(BasicPal &&) = default;

        BasicPal(const BasicPal &other):
            size_(other.size_),
            data_(std::make_unique<char[]>(size_ * sizeof(T)))
        {
            std::copy(other.data_.get(), other.data_.get() + size_ * sizeof(T), data_.get());
        }

        template<class InputIt>
        BasicPal(InputIt first, InputIt last):
            size_(static_cast<size_t>(std::distance(last, first))),
            data_(std::make_unique<char[]>(size_ * sizeof(T)))
        {
            std::copy(first, last, data());
        }

        BasicPal(const BasicPalRef<T> &other):
            BasicPal(other.begin(), other.end()) {}

        BasicPal &operator=(BasicPal &&) noexcept = default;

        BasicPal &operator=(const BasicPal &other)
        {
            size_ = other.size_;
            data_ = std::make_unique<char[]>(size_ * sizeof(T));
            std::copy(other.data_.get(), other.data_.get() + size_ * sizeof(T), data_.get());
            return *this;
        }

        T *data()
        { return reinterpret_cast<T *>(data_.get()); }

        const T *data() const
        { return reinterpret_cast<const T *>(data_.get()); }

        void reset()
        { *this = BasicPal(); }

        bool empty() const
        { return size_ == 0; }

        PixelFormat format() const
        { return format_; }

        size_t size() const
        { return size_; }

        T &at(size_t i)
        {
            if (i >= size())
                throw std::out_of_range { "Palette::at" };
            return data()[i];
        }

        const T &at(size_t i) const
        {
            if (i >= size())
                throw std::out_of_range { "const Palette::at" };
            return data()[i];
        }

        template<class U>
        T &at(U i)
        {
            static_assert(detail::pixel_info<U>::is_index, "Palette index must be of type Index");
            if (i >= size())
                throw std::out_of_range { "Palette::at" };
            return data()[i.index];
        }

        template<class U>
        const T &at(U i) const
        {
            static_assert(detail::pixel_info<U>::is_index, "Palette index must be of type Index");
            if (i >= size())
                throw std::out_of_range { "const Palette::at" };
            return data()[i.index];
        }

        T &operator[](size_t i)
        { return data()[i]; }

        const T &operator[](size_t i) const
        { return data()[i]; }

        template<class U>
        T &operator[](U i)
        {
            static_assert(detail::pixel_info<U>::is_index, "Palette index must be of type Index");
            return data()[i.index];
        }

        template<class U>
        const T &operator[](U i) const
        {
            static_assert(detail::pixel_info<U>::is_index, "Palette index must be of type Index");
            return data()[i.index];
        }

        T *begin()
        { return data(); }

        const T *begin() const
        { return data(); }

        const T *cbegin() const
        { return data(); }

        T *end()
        { return data() + size(); }

        const T *end() const
        { return data() + size(); }

        const T *cend() const
        { return data() + size(); }
    };

    template <class Func>
    void match(PixelFormat format, Func func)
    {
        switch(format) {
        case PixelFormat::none:
            break;

        case PixelFormat::index8:
            func(Index8{});
            break;

        case PixelFormat::rgb:
            func(Rgb{});
            break;

        case PixelFormat::rgba:
            func(Rgba{});
            break;

        case PixelFormat::rgba5551:
            func(Rgba5551{});
            break;
        }
    }

    template <class Func1, class Func2>
    auto match(PixelFormat type, Func1 func1, Func2 func2)
    {
        switch (type) {
        case PixelFormat::none:
            break;

        case PixelFormat::rgb:
            return func1(Rgb{});

        case PixelFormat::rgba:
            return func1(Rgba{});

        case PixelFormat::rgba5551:
            return func1(Rgba5551{});

        case PixelFormat::index8:
            return func2(Index8{});
        }

        return decltype(func1(Rgb{})) {};
    }
  }
}

#endif //__IMP_PIXEL__13206666

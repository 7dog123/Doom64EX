// -*- mode: c++ -*-
#ifndef __IMP_PROPERTY__90140360
#define __IMP_PROPERTY__90140360

#include <imp/util/Convert>
#include <imp/util/Clamped>
#include <imp/Prelude>

namespace std {
  inline String to_string(String x)
  { return x; }
}

namespace imp {
  template <class T>
  class TypedProperty;

  class Property {
      String mName;
      String mDescription;
      int mFlags;

  protected:
      virtual String p_value() const = 0;
      virtual void p_set_value(StringView) = 0;

      virtual String p_default() const = 0;
      virtual void p_set_to_default() = 0;

  public:
      /*! Don't save the property in config.cfg */
      static constexpr int noconfig  = 0x1;
      /*! Readonly if sv_cheats == 0 */
      static constexpr int cheat   = 0x2;
      /*! Don't display in console */
      static constexpr int hidden  = 0x4;
      /*! Synchronise the value with the server */
      static constexpr int network = 0x8;

      static std::vector<Property *> all();

      /*!
       * \brief Look for a property
       * \param name Property name
       * \return A Property instance or nullptr if not found
       */
      static Property* find(StringView name);

      /*!
       * \brief Look for a typed property
       * \tparam T Property type
       * \param name Property name
       * \return A TypeProperty instance or nullptr if not found
       */
      template <class T>
      static TypedProperty<T>* find(StringView name)
      {
          return dynamic_cast<TypedProperty<T>*>(find(name));
      }

      /*!
       * Get a list of all properties that whose name starts with a prefix
       * @param prefix Prefix to search for
       * @return a list of non-hidden properties
       */
      static Vector<Property *> partial(StringView prefix);

      Property(StringView name, StringView description, int flags = 0);

      virtual ~Property();

      StringView name() const
      {
          return mName;
      }

      StringView description() const
      {
          return mDescription;
      }

      int flags() const
      { return mFlags; }

      bool is_noconfig() const
      { return (mFlags & noconfig) != 0; }

      bool is_cheat() const
      { return (mFlags & cheat) != 0; }

      bool is_hidden() const
      { return (mFlags & hidden) != 0; }

      bool is_network() const
      { return (mFlags & network) != 0; }

      String value() const
      { return p_value(); }

      void set_value(StringView str)
      {
          p_set_value(str);
          update();
      }

      String default_value() const
      { return p_default(); }

      void set_to_default()
      {
          p_set_to_default();
          update();
      }

      void update();
  };

  template <class T>
  class TypedProperty : public Property {
      using setter_func = T (*)(const TypedProperty &property, T newValue);

      setter_func mSetter {};

      const T mDefault;

      T mValue;

  public:
      TypedProperty(StringView name, StringView description):
          Property(name, description, 0),
          mDefault(T()),
          mValue(T()) {}

      TypedProperty(StringView name, StringView description, T def, int flags = 0, setter_func setter = nullptr):
          Property(name, description, flags),
          mSetter(setter),
          mDefault(def),
          mValue(def) {}

      const T& native_value() const
      { return mValue; }

      operator T() const
      { return mValue; }

      template <class U>
      TypedProperty& operator=(U value)
      {
          mValue = mSetter ? mSetter(*this, value) : value;
          update();
          return *this;
      }

      void set(const T &value)
      {
          mValue = value;
      }

  protected:

      String p_value() const override
      {
          return std::to_string(mValue);
      }

      String p_default() const override
      {
          return std::to_string(mDefault);
      }

      void p_set_value(StringView strValue) override
      {
          auto value = from_string<T>(strValue);
          mValue = mSetter ? mSetter(*this, value) : value;
      }

      void p_set_to_default() override
      {
          mValue = mDefault;
      }
  };

  using IntProperty = TypedProperty<int>;
  using FloatProperty = TypedProperty<float>;
  using ClampedIntProperty = TypedProperty<Clamped<int>>;
  using ClampedFloatProperty = TypedProperty<Clamped<float>>;
  using BoolProperty = TypedProperty<bool>;
  using StringProperty = TypedProperty<String>;
}

#define __IMP_TYPEDPROPERTY_ARITHMETIC_OPERATORS(Op) \
template <class T, class U> constexpr T operator Op(const imp::TypedProperty<T> &l, const U &r) { return l.native_value() Op r; } \
template <class T, class U> constexpr T operator Op(const T &l, const imp::TypedProperty<U> &r) { return l Op r.native_value(); }

__IMP_TYPEDPROPERTY_ARITHMETIC_OPERATORS(+)
__IMP_TYPEDPROPERTY_ARITHMETIC_OPERATORS(-)
__IMP_TYPEDPROPERTY_ARITHMETIC_OPERATORS(*)
__IMP_TYPEDPROPERTY_ARITHMETIC_OPERATORS(/)
__IMP_TYPEDPROPERTY_ARITHMETIC_OPERATORS(%)

#undef __IMP_TYPEDPROPERTY_ARITHMETIC_OPERATORS

#define __IMP_TYPEDPROPERTY_COMPARISON_OPERATORS(Op) \
template <class T, class U> constexpr bool operator Op(const imp::TypedProperty<T> &l, const imp::TypedProperty<U> &r) { return l.native_value() Op r.native_value(); } \
template <class T, class U> constexpr bool operator Op(const imp::TypedProperty<T> &l, const U &r) { return l.native_value() Op r; } \
template <class T, class U> constexpr bool operator Op(const T &l, const imp::TypedProperty<U> &r) { return l Op r.native_value(); }

__IMP_TYPEDPROPERTY_COMPARISON_OPERATORS(==)
__IMP_TYPEDPROPERTY_COMPARISON_OPERATORS(!=)
__IMP_TYPEDPROPERTY_COMPARISON_OPERATORS(<)
__IMP_TYPEDPROPERTY_COMPARISON_OPERATORS(>)
__IMP_TYPEDPROPERTY_COMPARISON_OPERATORS(<=)
__IMP_TYPEDPROPERTY_COMPARISON_OPERATORS(>=)

#undef __IMP_TYPEDPROPERTY_COMPARISON_OPERATORS

#endif //__IMP_PROPERTY__90140360

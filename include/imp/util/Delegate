// -*- C++ -*-
#ifndef __IMP_DELEGATE__12838651
#define __IMP_DELEGATE__12838651

#include <utility>

namespace imp {
namespace detail {

template <class>
class method_function_ptr;

template <class RetT, class... Args>
class method_function_ptr<RetT (Args...)>
{
    struct stub_type {};
    using function_type = RetT (stub_type::*)(Args...);

    function_type function_ {};

public:
    method_function_ptr() {}

    method_function_ptr(std::nullptr_t) {}

    method_function_ptr(const method_function_ptr&) = default;

    method_function_ptr& operator=(const method_function_ptr&) = default;

    RetT operator()(void *object, Args... args)
    {
        auto stub = reinterpret_cast<stub_type>(object);
        return stub->*function_(args...);
    }
};

}

template <class>
class Delegate;

template <class RetT, class... Args>
class Delegate<RetT (Args...)> {
    using function_type = RetT (*)(Args...);
    using method_type = detail::method_function_ptr<RetT (Args...)>;
    using object_type = void;

    object_type *object_ {};

    union {
        function_type *function_;
        method_type method_;
    };

public:
    Delegate(): function_(nullptr) {}

    Delegate(const Delegate&) = default;

    Delegate(function_type *function): function_(function) {}

    template <class Klass>
    Delegate(Klass *object, RetT (Klass::*method)(Args...)):
        object_(object),
        method_(method) {}

    Delegate& operator=(const Delegate&) = default;

    RetT operator()(Args... args)
    {
        if (object_) {
            return method_(object_, args...);
        } else {
            return function_(args...);
        }
    }
};

}

#endif //__IMP_DELEGATE__12838651

// -*- mode: c++ -*-
//-----------------------------------------------------------------------------
//
// Copyright(C) 2016 Zohar Malamant
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
// 02111-1307, USA.
//
//-----------------------------------------------------------------------------

#ifndef __IMP_IMAGE__96112498
#define __IMP_IMAGE__96112498

#include <istream>
#include "Pixel"

namespace imp {
  namespace gfx {
    class Image;

    struct ImageFormatIO {
        virtual bool is_format(std::istream&) const = 0;
        virtual Image load(std::istream&) const = 0;
        virtual void save(std::ostream&, Image const&) const = 0;
        virtual StringView mimetype() const = 0;
    };

    struct SpriteOffsets {
        int x = 0;
        int y = 0;
    };

    enum struct ImageFormat {
        png,
        doom
    };

    template <class T, class PalT>
    class BasicImage;

    template <class T, class PalT>
    class BasicImageRef;

    template <class T, class PalT = void>
    class BasicScanline {
        static_assert(detail::is_index<T>, "T must be of index pixel type");

        friend class BasicImage<T, PalT>;
        friend class BasicImageRef<T, PalT>;

        static constexpr auto format_ = T::format;
        BasicPal<PalT>* pal_ {};
        T* data_ {};
        int16 width_ {};

        BasicScanline(BasicPal<PalT>& pal, T* data, int16 width):
            pal_(&pal),
            data_(data),
            width_(width) {}
    public:
        BasicScanline() = default;

        BasicScanline(BasicScanline&&) = default;

        BasicScanline(const BasicScanline&) = default;

        BasicScanline& operator=(BasicScanline&&) = default;

        BasicScanline& operator=(const BasicScanline&) = default;

        T* data()
        { return data_; }

        const T* data() const
        { return data_; }

        int16 width() const
        { return width_; }

        size_t size() const
        { return static_cast<size_t>(width_); }

        BasicPal<PalT>& pal()
        { return *pal_; }

        const BasicPal<PalT>& pal() const
        { return *pal_; }

        T* begin()
        { return data_; }

        const T* begin() const
        { return data_; }

        const T* cbegin() const
        { return data_; }

        T* end()
        { return data_ + width_; }

        const T* end() const
        { return data_ + width_; }

        const T* cend() const
        { return data_ + width_; }

        T& operator[](size_t i)
        { return pal_[data_[i]]; }

        const T& operator[](size_t i) const
        { return pal_[data_[i]]; }
    };

    template <class T, class PalT = void>
    class BasicImage {
        static_assert(detail::is_index<T>, "T must be of index pixel type");

        static constexpr auto format_ = T::format;
        int16 width_ {};
        int16 height_ {};
        int16 pitch_ {};
        std::unique_ptr<char[]> data_ {};
        BasicPal<PalT> pal_ {};

        size_t allocsize_() const
        { return static_cast<size_t>(pitch_) * static_cast<size_t>(height_) * sizeof(T); }

    public:
        BasicImage() = default;

        BasicImage(BasicImage&&) = default;

        BasicImage(const BasicImage& other):
            width_(other.width_),
            height_(other.height_),
            pitch_(other.pitch_),
            data_(std::make_unique<char[]>(other.allocsize_())),
            pal_(other.pal_)
        {
            std::copy(other.data_.get(), other.data_.get() + other.allocsize_(), data_.get());
        }

        BasicImage& operator=(BasicImage&&) = default;

        BasicImage& operator=(const BasicImage& other)
        {
            width_ = other.width_;
            height_ = other.height_;
            pitch_ = other.pitch_;
            data_ = std::make_unique<char[]>(other.allocsize_());
            std::copy_n(other.data_.get(), other.allocsize_(), data_.get());
            return *this;
        }

        int16 width() const
        { return width_; }

        int16 height() const
        { return height_; }

        int16 pitch() const
        { return pitch_; }

        BasicScanline<T, PalT> operator[](size_t i)
        { return { pal_, reinterpret_cast<T*>(data_.get() + static_cast<size_t>(pitch) * i), width_ }; };

        BasicScanline<const T, const PalT> operator[](size_t i) const
        { return { pal_, reinterpret_cast<T*>(data_.get() + static_cast<size_t>(pitch) * i), width_ }; };
    };

    template <class T>
    class BasicScanline<T, void> {
        static_assert(detail::is_color<T>, "T must be of color pixel type");

        friend class BasicImage<T, void>;
        friend class BasicImageRef<T, void>;

        static constexpr auto format_ = T::format;
        int16 width_ {};
        T* data_ {};

        BasicScanline(int16 width, T* data):
            width_(width),
            data_(data_) {}

    public:
        BasicScanline() = default;

        BasicScanline(const BasicScanline&) = default;

        BasicScanline& operator=(const BasicScanline&) = default;

        T* data()
        { return data_; }

        const T* data() const
        { return data_; }
    };

    template <class T, class PalT>
    class BasicImageRef {
        static_assert(detail::is_index<T>, "T must be of index pixel type");

        static constexpr auto format_ = T::format;
        int16 width_ {};
        int16 height_ {};
        int16 pitch_ {};
        char *data_ {};
        BasicPalRef<PalT> pal_ {};

    public:
        BasicImageRef() = default;

        BasicImageRef(const BasicImageRef&) = default;

        BasicImageRef(Image& other):
            width_(other.width()),
            height_(other.height()),
            pitch_(other.pitch()),
            data_(other.data()),
            pal_(other.pal().ref<PalT>()) {}

        BasicImageRef& operator=(const BasicImageRef&) = default;
    };

    /**
     * \brief A container type for images
     */
    class Image {
        PixelFormat format_ {};
        int16 width_ {};
        int16 height_ {};
        int16 pitch_ {};
        std::unique_ptr<char[]> data_ {};
        Pal pal_ {};
        SpriteOffsets offsets_ {};

    public:
        Image() = default;

        Image(Image&&) = default;

        Image(const Image &);

        Image(std::istream&);

        Image(std::istream&, ImageFormat format);

        Image& operator=(const Image &);

        Image& operator=(Image&&) = default;

        void load(std::istream&);

        void load(std::istream&, ImageFormat format);

        void save(std::ostream& s, ImageFormat format) const;

        void clear()
        { *this = {}; }

        char* data()
        { return data_.get(); }

        const char* data() const
        { return data_.get(); }

        template<class T, class PalT = void>
        BasicImageRef<T, PalT> ref()
        {
            if (format_ != T::format)
                throw std::logic_error("Image pixel type error");
            return *this;
        }

        PixelFormat format() const
        { return format_; }

        int16 width() const
        { return width_; }

        int16 height() const
        { return height_; }

        int16 pitch() const
        { return pitch_; }

        Pal &pal()
        { return pal_; }

        const Pal& pal() const
        { return pal_; }

        PixelFormat pal_format() const
        { return pal_ ? pal_.format() : PixelFormat::none; }

        void set_pal(Pal pal)
        { pal_ = std::move(pal); }

        SpriteOffsets offsets() const
        { return offsets_; }

        void set_offsets(const SpriteOffsets &offsets)
        { offsets_ = offsets; }

        template <class T>
        class ImageRef {
            Image& ref_;
            size_t width_ {};
            size_t height_ {};
            size_t pitch_ {};

            ImageRef(Image& parent):
                ref_(parent),
                width_(parent.width()),
                height_(parent.height()),
                pitch_(parent.pitch()) {}

            friend class Image;
        public:

            T* data()
            { return reinterpret_cast<T*>(ref_.data()); }

            const T* data() const
            { return reinterpret_cast<T*>(ref_.data()); }
        };
    };

    gfx::Image scale(gfx::Image, size_t new_width, size_t new_height);

    /**
     * \brief Equality operator for Image
     *
     * \return true if images are isomorphic, false otherwise
     *
     * Compares two Image classes. Only returns true if `lhs` is isomorphic to `rhs`.
     * That is, if `lhs` can be losslessly converted to `rhs` and vice-versa.
     */
    bool operator==(const Image &lhs, const Image &rhs);

    /**
     * \brief Inequality operator for Image
     *
     * \return true if images are not isomorphic, false otherwise
     *
     * Compares two Image classes. Only returns false if `lhs` is isomorphic to `rhs`.
     * That is, if `lhs` can be losslessly converted to `rhs` and vice-versa.
     */
    bool operator!=(const Image &lhs, const Image &rhs);
  }
}

#endif //__IMP_IMAGE__96112498
